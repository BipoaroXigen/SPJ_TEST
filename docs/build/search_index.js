var documenterSearchIndex = {"docs":
[{"location":"tsp/#Traveling-salesman-problem","page":"Traveling salesman problem","title":"Traveling salesman problem","text":"","category":"section"},{"location":"tsp/","page":"Traveling salesman problem","title":"Traveling salesman problem","text":"Here, we show, how a solver can be set up to solve the Traveling salesman (TSP) problem.","category":"page"},{"location":"tsp/","page":"Traveling salesman problem","title":"Traveling salesman problem","text":"All of the examples are available in the TSP.ipynb notebook in the /notebooks directory. The solved TSP problems are from the web page: http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/ . The notebook expects the instances in a folder TSP_problems/.","category":"page"},{"location":"tsp/","page":"Traveling salesman problem","title":"Traveling salesman problem","text":"","category":"page"},{"location":"tsp/#Local-search-solver","page":"Traveling salesman problem","title":"Local search solver","text":"","category":"section"},{"location":"tsp/","page":"Traveling salesman problem","title":"Traveling salesman problem","text":"The solver minimizes the length of a sequence of vertices of a graph G, which is defined by a distance matrix.","category":"page"},{"location":"tsp/","page":"Traveling salesman problem","title":"Traveling salesman problem","text":"G = # distance matrix for the problem graph\npop_size = 1\ndimension = size(G, 1)\n\nobjective_function  = enclose_arguments(EO.f_dist_sum, G)\ninitialization      = enclose_noargs(TSP_initialization, dimension, pop_size, objective_function)   # initialize random vertex sequences\nselection           = EO.s_identity\ncrossover           = identity\nmutation            = [enclose_arguments(EO.order_switch!, G), enclose_arguments(EO.pair_switch!, G), enclose_arguments(EO.weaklink_preturbation!, G)]\nreplacement         = EO.enclose_replacement(r_keep_best_n, pop_size)\ntermination         = enclose_argument(iteration_termination, 50000)    # maximal number of objective function calls","category":"page"},{"location":"tsp/#Evolutionary-strategy","page":"Traveling salesman problem","title":"Evolutionary strategy","text":"","category":"section"},{"location":"tsp/","page":"Traveling salesman problem","title":"Traveling salesman problem","text":"Setting the population size above 1 and providing the solver with selection and crossover functions, the local search can be changed into an evolutionary algorithm.","category":"page"},{"location":"tsp/","page":"Traveling salesman problem","title":"Traveling salesman problem","text":"G = # distance matrix for the problem graph\npop_size = 100\ndimension = size(G, 1)\n\nobjective_function  = enclose_arguments(EO.f_dist_sum, G)\ninitialization      = enclose_noargs(TSP_initialization, dimension, pop_size, objective_function)\nselection           = enclose_arguments(s_tournament, pop_size*3, round(Int, pop_size/3))\ncrossover           = [EO.cr_ordered, EO.cr_subtour, EO.cr_edge_recombination]\nmutation            = enclose_arguments(EO.order_switch!, G)\nreplacement         = EO.enclose_replacement(r_keep_best_n, pop_size)\ntermination         = enclose_argument(iteration_termination, 5000#= 0 =#)","category":"page"},{"location":"tsp/","page":"Traveling salesman problem","title":"Traveling salesman problem","text":"","category":"page"},{"location":"tsp/","page":"Traveling salesman problem","title":"Traveling salesman problem","text":"Showcase of memetic algorithm, heuristic initialization of initial population and results of benchmarks can be found in the TSP.ipynb notebook.","category":"page"},{"location":"operators/#Introduction-and-Operator-functions","page":"Introduction and Operator functions","title":"Introduction and Operator functions","text":"","category":"section"},{"location":"operators/","page":"Introduction and Operator functions","title":"Introduction and Operator functions","text":"The solver evolves a population of solutions. The solutions are initialized, modified and evolved accordingly to functions the solver obtains as agruments. The specific types of functions are explained later.","category":"page"},{"location":"operators/","page":"Introduction and Operator functions","title":"Introduction and Operator functions","text":"The solvers behaviour can be flexibly changed by the operator functions provided by the user. Operator functions in this context mean functions defining certain strategies for evolutionary algorithms. The library contains several implemented operator functions, however the library is made with custom operator functions in mind, cince it is expected, the user will have ideas for functions defining his specific problem better.","category":"page"},{"location":"operators/","page":"Introduction and Operator functions","title":"Introduction and Operator functions","text":"","category":"page"},{"location":"operators/#Initialization","page":"Introduction and Operator functions","title":"Initialization","text":"","category":"section"},{"location":"operators/","page":"Introduction and Operator functions","title":"Introduction and Operator functions","text":"Function which (usually) randomly creates a population of solutions. Only requirement on the function is for it to return a population of a type which is subtype of EO.Population","category":"page"},{"location":"operators/","page":"Introduction and Operator functions","title":"Introduction and Operator functions","text":"Some initializations already present in the library are:","category":"page"},{"location":"operators/","page":"Introduction and Operator functions","title":"Introduction and Operator functions","text":"EO.interval_real_initialization(dims::Int, size::Int, f::Function, lb::T, ub::T) where T<:Real\nEO.TSP_initialization(dims::Int, size::Int, f::Function)\nEO.expression_initialization(size::Int, f::Function, basis_functions::Vector{Function}, basis_variables::Vector{Any})\n","category":"page"},{"location":"operators/#Selection","page":"Introduction and Operator functions","title":"Selection","text":"","category":"section"},{"location":"operators/","page":"Introduction and Operator functions","title":"Introduction and Operator functions","text":"Function which selects from the current population parents of the next genertion. Expected output is a vector indexing the selected parents from the population.","category":"page"},{"location":"operators/","page":"Introduction and Operator functions","title":"Introduction and Operator functions","text":"Some selections already present in the library are:","category":"page"},{"location":"operators/","page":"Introduction and Operator functions","title":"Introduction and Operator functions","text":"EO.s_tournament(p::SingleObjPopulation, out_n::Int, poll_size::Int)::Vector{Int}\nEO.s_stochastic_tournament(p::Population, out_n::Int, poll_size::Int, constraints::Vector{Constraint}, P::Float64)::Vector{Int}\nEO.s_greedy_overselection(p::SingleObjPopulation, out_n::Int, prc::Float64)::Vector{Int}\n","category":"page"},{"location":"operators/#Crossover","page":"Introduction and Operator functions","title":"Crossover","text":"","category":"section"},{"location":"operators/","page":"Introduction and Operator functions","title":"Introduction and Operator functions","text":"Function combining parents into new solutions. The solver expects two functions, one implementing the creation of new solution from parent solutions, and other calling that function on the population <:EO.Population of parents Expected output is population <:EO.Population of children","category":"page"},{"location":"operators/","page":"Introduction and Operator functions","title":"Introduction and Operator functions","text":"Some crossovers already present in the library are:","category":"page"},{"location":"operators/","page":"Introduction and Operator functions","title":"Introduction and Operator functions","text":"EO.cr_single_point(a::T, b::T)::T where T<:Chromosome\nEO.cr_single_point(p<:Population)<:Population\n\nEO.cr_ordered(a::T, b::T)::T where T<:Chromosome\nEO.cr_ordered(p::Population)::Population\n\nEO.cr_subtree(a::ExprChromosome, b::ExprChromosome, basis_functions::Vector{Function}, basis_variables::Vector{Any})::Tuple{EO.ExprChromosome, EO.ExprChromosome}\nEO.cr_subtree(p::Population, out_n::Int, basis_functions::Vector{Function}, basis_variables::Vector{Any})::Population\n","category":"page"},{"location":"operators/#Replacement","page":"Introduction and Operator functions","title":"Replacement","text":"","category":"section"},{"location":"operators/","page":"Introduction and Operator functions","title":"Introduction and Operator functions","text":"Function combining current population with the children, into new population. The function is expected to accept two populations and return one population","category":"page"},{"location":"operators/","page":"Introduction and Operator functions","title":"Introduction and Operator functions","text":"Some replacements already present in the library are:","category":"page"},{"location":"operators/","page":"Introduction and Operator functions","title":"Introduction and Operator functions","text":"EO.r_replacement(old::Population, new::Population)::Population = new\nEO.r_merge(old<:Population, new<:Population)<:Population\nr_keep_best_n(old::Population, new::Population, n::Int)::Population","category":"page"},{"location":"operators/#Mutation","page":"Introduction and Operator functions","title":"Mutation","text":"","category":"section"},{"location":"operators/","page":"Introduction and Operator functions","title":"Introduction and Operator functions","text":"Function randomly mutating single solution Accepts solution as subtype of Chromosome and returns the same","category":"page"},{"location":"operators/","page":"Introduction and Operator functions","title":"Introduction and Operator functions","text":"Some mutations already present in the library are:","category":"page"},{"location":"operators/","page":"Introduction and Operator functions","title":"Introduction and Operator functions","text":"EO.basic_preturbation!(x::BinaryChromosome, p::Real)\nEO.gaussian_preturbation!(x::RealChromosome, p::Real)\nEO.pair_switch!(x::RealChromosome, G::Matrix{Float64})","category":"page"},{"location":"operators/#Objective-function","page":"Introduction and Operator functions","title":"Objective function","text":"","category":"section"},{"location":"operators/","page":"Introduction and Operator functions","title":"Introduction and Operator functions","text":"Function returning a scalar or vector of real numbers, which the solver minimizes","category":"page"},{"location":"operators/","page":"Introduction and Operator functions","title":"Introduction and Operator functions","text":"Some objectives already present in the library are:","category":"page"},{"location":"operators/","page":"Introduction and Operator functions","title":"Introduction and Operator functions","text":"EO.f_onemax(x::BinaryChromosome)::Int = sum(x.sequence)\nEO.f_sphere(x::RealChromosome, o::Vector{<:Real})::Float64 = sum((x.sequence.-o).^2)\nEO.f_dist_sum(x::RealChromosome, G::Matrix{Float64})::Float64 = sum( [G[x.sequence[i], x.sequence[i+1]] for i in 1:x.length-1] ) + G[x.sequence[1], x.sequence[end]]","category":"page"},{"location":"constrains/#Solvers-for-constrained-optimization","page":"Solvers for constrained optimization","title":"Solvers for constrained optimization","text":"","category":"section"},{"location":"constrains/","page":"Solvers for constrained optimization","title":"Solvers for constrained optimization","text":"The EO library can be for example used to solve constrained optimizaation problems with the following algorithms.","category":"page"},{"location":"constrains/","page":"Solvers for constrained optimization","title":"Solvers for constrained optimization","text":"The notebook constrained_optimization.ipynb demonstrates the use and performance of the library when applied to constrained analytical optimization problems. The notebook contains more examples than this page.","category":"page"},{"location":"constrains/#Stochastic-ranking","page":"Solvers for constrained optimization","title":"Stochastic ranking","text":"","category":"section"},{"location":"constrains/","page":"Solvers for constrained optimization","title":"Solvers for constrained optimization","text":"pop_size = 100\nobjective(x) = (x.sequence[1]-10)^3 + (x.sequence[2]-20)^3\nconstraints = [EO.constraint(x -> -(x[1]-5)^2 - (x[2]-5)^2 + 100, .<=, 0.), EO.constraint(x -> (x[1]-6)^2 + (x[2]-5)^2 − 82.81, .<=, 0.),\n\t\t\t\t\tEO.constraint(x -> -x[1]+13, <=, 0.), EO.constraint(x -> x[1]-100, <=, 0.), \n\t\t\t\t\tEO.constraint(x -> -x[2], <=, 0.), EO.constraint(x -> x[2]-100, <=, 0.)]\n\nobjective_function  = objective\ninitialization      = enclose_noargs(interval_real_initialization, dimension, pop_size, objective_function, 0, 100)\nselection           = enclose_arguments(EO.s_stochastic_tournament, 30, 3, constraints, 0.4)\ncrossover           = enclose_arguments(EO.cr_parent_sum, pop_size)\nmutation            = enclose_arguments(gaussian_preturbation!, 0.25)\nreplacement         = EO.enclose_replacement(EO.r_keep_best_n_stoch, pop_size, constraints, 0.4)\ntermination         = enclose_argument(iteration_termination, pop_size*100)\n\nsolution = solvink_hart(objective_function, initialization, selection, crossover, mutation, replacement, termination; constraints=constraints)","category":"page"},{"location":"constrains/#MOEA","page":"Solvers for constrained optimization","title":"MOEA","text":"","category":"section"},{"location":"constrains/","page":"Solvers for constrained optimization","title":"Solvers for constrained optimization","text":"Multi objective ES, where one objective dimension is the objective itself and the second objective is sum of all constraint violations.","category":"page"},{"location":"constrains/","page":"Solvers for constrained optimization","title":"Solvers for constrained optimization","text":"This approach has a problem caused by the nature of the pareto front, where a solution with great objective value, but terrible constraint violation can be considered as dominating.","category":"page"},{"location":"constrains/","page":"Solvers for constrained optimization","title":"Solvers for constrained optimization","text":"pop_size = 100\nobjective(x) = (x.sequence[1]-10)^3 + (x.sequence[2]-20)^3\nconstraints = [EO.constraint(x -> -(x[1]-5)^2 - (x[2]-5)^2 + 100, .<=, 0.), EO.constraint(x -> (x[1]-6)^2 + (x[2]-5)^2 − 82.81, .<=, 0.),\n\t\t\t\t\tEO.constraint(x -> -x[1]+13, <=, 0.), EO.constraint(x -> x[1]-100, <=, 0.), \n\t\t\t\t\tEO.constraint(x -> -x[2], <=, 0.), EO.constraint(x -> x[2]-100, <=, 0.)]\nf_pens(x::RealChromosome, constraints::Vector{EO.Constraint}) = sum(EO.Gs(x, constraints))\n\nF = typeof(enclose_arguments(EO.f_weighted_sum, ones(dimension)))\nobjective_function  = EO.MultiObjFunction{F}([objective, enclose_arguments(f_pens, constraints)])\ninitialization      = enclose_noargs(interval_real_initialization, dimension, pop_size, objective_function, 0, 100)\nselection           = enclose_arguments(EO.s_tournament, 30, 5)\ncrossover           = enclose_arguments(EO.cr_parent_sum, pop_size)\nmutation            = enclose_arguments(gaussian_preturbation!, 0.25)\nreplacement         = EO.enclose_replacement(EO.r_NSGA, pop_size)\ntermination         = enclose_argument(iteration_termination, pop_size*100)\n\nsolution = solvink_hart(objective_function, initialization, selection, crossover, mutation, replacement, termination)","category":"page"},{"location":"constrains/#Adaptive-penalization","page":"Solvers for constrained optimization","title":"Adaptive penalization","text":"","category":"section"},{"location":"constrains/","page":"Solvers for constrained optimization","title":"Solvers for constrained optimization","text":"The objective function is penalized by the sum of constraint violations, multiplied by rg(t) which controls the exploration exploitation tradeoff.","category":"page"},{"location":"constrains/","page":"Solvers for constrained optimization","title":"Solvers for constrained optimization","text":"\npop_size = 100\nobjective(x) = (x.sequence[1]-10)^3 + (x.sequence[2]-20)^3\nconstraints = [EO.constraint(x -> -(x[1]-5)^2 - (x[2]-5)^2 + 100, .<=, 0.), EO.constraint(x -> (x[1]-6)^2 + (x[2]-5)^2 − 82.81, .<=, 0.),\n\t\t\t\t\tEO.constraint(x -> -x[1]+13, <=, 0.), EO.constraint(x -> x[1]-100, <=, 0.), \n\t\t\t\t\tEO.constraint(x -> -x[2], <=, 0.), EO.constraint(x -> x[2]-100, <=, 0.)]\n\nobjective_function  = objective\ninitialization      = enclose_noargs(interval_real_initialization, dimension, pop_size, objective_function, 0, 100)\nselection           = enclose_arguments(EO.s_tournament, 30, 3)\ncrossover           = enclose_arguments(EO.cr_parent_sum, pop_size)\nmutation            = enclose_arguments(gaussian_preturbation!, 0.25)\nreplacement         = EO.enclose_replacement(EO.r_keep_best_n, pop_size)\ntermination         = enclose_argument(iteration_termination, pop_size*100)\n\nsolution = solvink_hart(objective_function, initialization, selection, crossover, mutation, replacement, termination; constraints=constraints, penalty=penatly);","category":"page"},{"location":"constrains/#NSGA-II-with-modified-tournament-operator","page":"Solvers for constrained optimization","title":"NSGA-II with modified tournament operator","text":"","category":"section"},{"location":"constrains/","page":"Solvers for constrained optimization","title":"Solvers for constrained optimization","text":"The best of here implemented multi objective approaches. The violation of constraints is also added into the binary tournament, preffering less violating solutions. This algorithm mas much denser pareto front around the looked for optimum.","category":"page"},{"location":"constrains/","page":"Solvers for constrained optimization","title":"Solvers for constrained optimization","text":"\npop_size = 100\nobjective(x) = (x.sequence[1]-10)^3 + (x.sequence[2]-20)^3\nconstraints = [EO.constraint(x -> -(x[1]-5)^2 - (x[2]-5)^2 + 100, .<=, 0.), EO.constraint(x -> (x[1]-6)^2 + (x[2]-5)^2 − 82.81, .<=, 0.),\n\t\t\t\t\tEO.constraint(x -> -x[1]+13, <=, 0.), EO.constraint(x -> x[1]-100, <=, 0.), \n\t\t\t\t\tEO.constraint(x -> -x[2], <=, 0.), EO.constraint(x -> x[2]-100, <=, 0.)]\n\nf_pens(x::RealChromosome, constraints::Vector{EO.Constraint}) = sum(EO.Gs(x, constraints))\n\nF = typeof(enclose_arguments(EO.f_weighted_sum, ones(dimension)))\nobjective_function  = EO.MultiObjFunction{F}([objective, enclose_arguments(f_pens, constraints)])\ninitialization      = enclose_noargs(interval_real_initialization, dimension, pop_size, objective_function, 0, 100)\nselection           = enclose_arguments(EO.s_tournament, 30, 3)\ncrossover           = enclose_arguments(EO.cr_parent_sum, pop_size)\nmutation            = enclose_arguments(gaussian_preturbation!, 0.25)\nreplacement         = EO.enclose_replacement(EO.r_cNSGA, pop_size, constraints)\ntermination         = enclose_argument(iteration_termination, pop_size*100)\n\nsolution = solvink_hart(objective_function, initialization, selection, crossover, mutation, replacement, termination)\n","category":"page"},{"location":"solver/#Simple-solver-examples","page":"Simple solver examples","title":"Simple solver examples","text":"","category":"section"},{"location":"solver/","page":"Simple solver examples","title":"Simple solver examples","text":"Here, we show, how a solver can be set up by providing it functions which define its behaviour.","category":"page"},{"location":"solver/","page":"Simple solver examples","title":"Simple solver examples","text":"All of the examples are available in the zoo.ipynb notebook in the /notebooks directory.","category":"page"},{"location":"solver/","page":"Simple solver examples","title":"Simple solver examples","text":"","category":"page"},{"location":"solver/#Single-objective-optimization","page":"Simple solver examples","title":"Single objective optimization","text":"","category":"section"},{"location":"solver/","page":"Simple solver examples","title":"Simple solver examples","text":"A simple solver for finding the minimum of 10-dimensional parabole. Any other user defined function, with its arguments, can be chosen.","category":"page"},{"location":"solver/","page":"Simple solver examples","title":"Simple solver examples","text":"using EO\n\ndims = 10\npop_size = 100\nobjective_function  = enclose_arguments(f_sphere, zeros(dims))  # min at origin\ninitialization      = enclose_noargs(interval_real_initialization, dims, pop_size, objective_function, 0, 100)\nselection           = enclose_arguments(EO.s_tournament, pop_size, 3)\ncrossover           = enclose_arguments(EO.cr_parent_sum, pop_size)\nmutation            = enclose_arguments(gaussian_preturbation!, 0.25)\nreplacement         = EO.enclose_replacement(EO.r_keep_best_n, pop_size)\ntermination         = enclose_argument(iteration_termination, pop_size*100)\nsolution            = solvink_hart(objective_function, initialization, selection, crossover, mutation, replacement, termination)","category":"page"},{"location":"solver/#Multiple-objectives","page":"Simple solver examples","title":"Multiple objectives","text":"","category":"section"},{"location":"solver/","page":"Simple solver examples","title":"Simple solver examples","text":"With a small modification, the solver can be edited to minimize two (or more) objectives at once.","category":"page"},{"location":"solver/","page":"Simple solver examples","title":"Simple solver examples","text":"pop_size = 100\ndimension = 2\n\nF = typeof(enclose_arguments(EO.f_weighted_sum, ones(dimension)))\nobjective_function  = EO.MultiObjFunction{F}([enclose_arguments(EO.f_sphere, ones(dimension)), EO.f_rastrigin])\ninitialization      = enclose_noargs(interval_real_initialization, dimension, pop_size, objective_function, -100, 100)\nselection           = enclose_arguments(EO.s_identity, pop_size*2)\ncrossover           = cr_single_point\nmutation            = enclose_arguments(gaussian_preturbation!, 0.25)\nreplacement         = EO.enclose_replacement(EO.r_NSGA, pop_size)\ntermination         = enclose_argument(iteration_termination, 10000)\n\nsolution = solvink_hart(objective_function, initialization, selection, crossover, mutation, replacement, termination)","category":"page"},{"location":"solver/#Genetic-programming","page":"Simple solver examples","title":"Genetic programming","text":"","category":"section"},{"location":"solver/","page":"Simple solver examples","title":"Simple solver examples","text":"The solver can be also, purely by providing different functions to the solver, used for symbolic regression.","category":"page"},{"location":"solver/","page":"Simple solver examples","title":"Simple solver examples","text":"pop_size = 300\n\n#objective_function  = enclose_arguments(EO.f_function_diff_subset, x, y, 0.9)\nobjective_function  = enclose_arguments(EO.f_function_diff_squared, y, x)\ninitialization      = enclose_noargs(EO.expression_initialization, pop_size, objective_function, basis_functions, basis_variables)\nselection           = enclose_arguments(EO.s_tournament, 100, 3)\n#selection           = enclose_arguments(EO.s_greedy_overselection, pop_size, 0.16)\ncrossover           = enclose_arguments(EO.cr_subtree, pop_size, basis_functions, basis_variables)\n#crossover           = enclose_arguments(EO.cr_GSGP, pop_size, basis_functions, basis_variables)\nmutation            = enclose_arguments(EO.subtree_mutation!, basis_functions, basis_variables)\nreplacement         = enclose_replacement(EO.r_best_n_diverse, pop_size, 0.7)       # chosen fraction of the population will consist of the best n, the rest is random\ntermination         = enclose_argument(iteration_termination, pop_size*20)\n\nsolution = solvink_hart(objective_function, initialization, selection, crossover, mutation, replacement, termination)\n\nmodel = EO.Expr_parser(solution.top_coords);","category":"page"},{"location":"solver/#Nested-Evolutionary-Feature-Selection","page":"Simple solver examples","title":"Nested Evolutionary Feature Selection","text":"","category":"section"},{"location":"solver/","page":"Simple solver examples","title":"Simple solver examples","text":"To be able to regress much more complex functions I came up with my own algorith based on https://dl.acm.org/doi/10.1145/2739480.2754693.","category":"page"},{"location":"solver/","page":"Simple solver examples","title":"Simple solver examples","text":"variables = [domain]\n#= operations = Vector{Function}([+, -, *, protected_div, sin, cos, square, cube, logaritmus, power])\narities =    [2,2,2,2,1,1, 1, 1, 1, 2] =#\noperations = Vector{Function}([+, -, *, EO.protected_div, EO.sin, EO.square, EO.cube, EO.logaritmus])\narities =    [2,2,2,2,1,1,1,1]\nexprs = Vector{Any}([:x])\n\nbest_model, models_hist = EO.feature_synthesis(y, variables, operations, arities, exprs, 10, q=10, μ=3, max_depth=10);","category":"page"},{"location":"#EO","page":"Home","title":"EO","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is a Julia library for evolutionary optimization. The library was written mainly with focus on flexibility of a solver, whose behaviour (the evolution strategy) is defined by user supplied functions as arguments (eg, crossover function etc.).","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install the package by running using Pkg; Pkg.add(\"https://github.com/BipoaroXigen/SPJ_TEST\") , or ]add https://github.com/BipoaroXigen/SPJ_TEST in REPL.","category":"page"},{"location":"#Examples-of-use","page":"Home","title":"Examples of use","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We provide several jupyter notebooks which help the user see how the library can be utilized. The notebooks can be found in the directory notebooks.","category":"page"},{"location":"#Showcase-of-basic-optimalization-problems-solvers","page":"Home","title":"Showcase of basic optimalization problems solvers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The notebook zoo.ipynb demonstrates the how the EO library can be used to solve variou types of optimization problems, such as optimization of simple function, multiobjective function, or symbolic regression by Genetic Programing.","category":"page"},{"location":"#Solving-the-TSP-problem","page":"Home","title":"Solving the TSP problem","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The notebook TSP.ipynb demonstrates the use and performance of the library when applied to the TSP problem. The solved TSP problems are from the web page: http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/ . The notebook expects the instances in a folder TSP_problems/.","category":"page"},{"location":"#Multiobjective-optimization","page":"Home","title":"Multiobjective optimization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The notebook multiobjective.ipynb demonstrates the use and performance of the library when applied to constrained analytical optimization problems. And the definitions of some problems are already prepared in the code.","category":"page"},{"location":"#Optimization-of-constrained-functions","page":"Home","title":"Optimization of constrained functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The notebook constrained_optimization.ipynb demonstrates the use and performance of the library when applied to constrained analytical optimization problems. The solved TSP problems are from the web page: https://cw.fel.cvut.cz/wiki/media/courses/a0m33eoa/cviceni/2006problemdefinitionsandevaluationcriteriaforthecec2006specialsessiononconstraintreal-parameteroptimization.pdf. And the definitions of some problems are already prepared in the code.","category":"page"},{"location":"#Algorithmic-trading","page":"Home","title":"Algorithmic trading","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The folder trading contains notebooks of an algorithmic trading project, built with this library.","category":"page"},{"location":"types/#Data-types-and-structures","page":"Data types and structures","title":"Data types and structures","text":"","category":"section"},{"location":"types/","page":"Data types and structures","title":"Data types and structures","text":"The EO library relies on data structures defined in src/structs.jl","category":"page"},{"location":"types/#Chromosome","page":"Data types and structures","title":"Chromosome","text":"","category":"section"},{"location":"types/","page":"Data types and structures","title":"Data types and structures","text":"Is a structure for the solutions in the population. The solver expects subtypes of this type, allowing the use for defining his custom format of the solutions. The library currently has its own implementationf of","category":"page"},{"location":"types/","page":"Data types and structures","title":"Data types and structures","text":"mutable struct BinaryChromosome <: Chromosome\n    sequence::Vector{Bool}\n    length::Int\nend\nmutable struct RealChromosome <: Chromosome\n    sequence::Vector{Real}\n    length::Int\nend\nmutable struct ExprChromosome <: Chromosome\n    sequence::Expr\n    length::Int\nend","category":"page"},{"location":"types/#Population","page":"Data types and structures","title":"Population","text":"","category":"section"},{"location":"types/","page":"Data types and structures","title":"Data types and structures","text":"Is a structure for handling the populations. The solver expects subtypes of this type, allowing the use for defining his custom format of the population. The library currently has its own implementationf of","category":"page"},{"location":"types/","page":"Data types and structures","title":"Data types and structures","text":"mutable struct SingleObjPopulation{T<:Chromosome} <: Population\n    population::Vector{T}\n    fitness::Vector{<:Real}\n    penalty::Vector{Float64}\n    size::Int\nend\n\nmutable struct MultiObjPopulation{T<:Chromosome} <: Population\n    population::Vector{T}\n    fitness::Vector{Vector{<:Real}}\n    penalty::Vector{Float64}\n    size::Int\nend","category":"page"},{"location":"types/#Result","page":"Data types and structures","title":"Result","text":"","category":"section"},{"location":"types/","page":"Data types and structures","title":"Data types and structures","text":"A data structure returned by the solver The solver expects subtypes of this type, allowing the use for defining his custom format of the result.","category":"page"},{"location":"types/","page":"Data types and structures","title":"Data types and structures","text":"mutable struct Result_real <: Result\n    top_coords::Vector{<:Real}\n    top_value::Float64\n    coords_history::Vector{Vector{<:Real}}\n    value_history::Vector{Float64}\nend\n\nmutable struct Result_binary <: Result\n    top_coords::Vector{Bool}\n    top_value::Float64\n    coords_history::Vector{Vector{Bool}}\n    value_history::Vector{Float64}\nend\n\nmutable struct Result_big <: Result\n    top_coords::Any\n    top_value::Float64\n    coords_history::Vector{Any}\n    value_history::Vector{Float64}\n    pop_history::Vector{<:Population}\n    penalty_history::Vector{Float64}\nend","category":"page"},{"location":"types/#Constraint","page":"Data types and structures","title":"Constraint","text":"","category":"section"},{"location":"types/","page":"Data types and structures","title":"Data types and structures","text":"A data structure for handling constraints of objectives ","category":"page"},{"location":"types/","page":"Data types and structures","title":"Data types and structures","text":"struct Constraint\n    leftside::Function\n    operator::Function\n    constr_value::Float64\nend","category":"page"},{"location":"types/","page":"Data types and structures","title":"Data types and structures","text":"Examples of setting up the constraints can be seen in src/utils.jl.","category":"page"}]
}
